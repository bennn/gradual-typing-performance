summarize
=========

Scripts for summarizing results.

The entry point is `main.py`; it expects a raw `.rktd` file generated by the run script and a module graph for the dataset.
Running:
```
python main.py OUTPUT.rktd
```
saves a few pictures and a `.tex` file to a new directory.
The module graph is inferred from the string `OUTPUT`.

This is an ad-hoc collection of summary scripts and bindings to matplotlib.
For now, the main source of truth are the code, comments, and purpose statements in the files themselves.
Things will be cleaner in about 2 months.

Pre-Requisites
--------------
Nearly everything here is implemented in Python.
You should install Python 3 and [pip](https://pypi.python.org/pypi/pip), then download the extra packages.

- [Racket](http://www.racket-lang.org)
- [Python 3](https://www.python.org/downloads/) (will probably work with Python 2.7)
- [matplotlib](http://matplotlib.org/downloads.html)
- [networkx](https://networkx.github.io/download.html)
- [numpy](http://www.numpy.org/)

As a heads up, we'll probably add these dependencies in the future:
- [SciPy](http://www.scipy.org/)
- [pandas](http://pandas.pydata.org/)
- [seaborn](http://stanford.edu/~mwaskom/software/seaborn/)

Basic Usage + Assumptions
-------------------------
### Background
The purpose of these scripts is to learn from raw data collected on gradual typing.
We begin with data generated by the `run.rkt` script from this repository and summarize the information it produces.

The run script takes a project folder as input and runs all gradually-typed configurations a specified number of times.
It saves the results of each run into a 2-dimensional vector.
The first dimension is the configuration (aka, the set of typed modules) and the second is a particular run of that configuration.

### Usage
Two inputs are necessary to run our `main.py` script.
1. Output from the `run.rkt` script representing a 2-d array
   Alternatively, a spreadsheet `OUTPUT.tab` matching the specification below.
2. A module graph for the project matching the specification below.
   If the input data is titled `foo.rktd`, the module graph must be called `foo.rktd` and stored in the same directory tree as either the current directory or the `foo.rktd` file (we do some searching for you, but not much).
   The exception to this naming convention are hyphen characters; each of `foo.rktd`, `foo-2.rktd`, and `foo-april-1.rktd` will infer the module graph `foo.graph`.

### Supported Data Formats
#### .rktd
Output from the `run.rkt` script is by definition valid input.

#### .tab
Because outputs from `run.rkt` are not very readable, our `main.py` generates a `.tab` file representing the same dataset.
Given `file.rktd`, we generate `file.tab` with contents like:
```
Run	1	2	3
00	88	89	88
01	121	212	150
10	177	121	221
11	3	3	3
```
The first row indexes the experiment runs (this row may be completely ignored).
All other rows name a configuration and list the experimental data for each run of that configuration.

#### directory (coming soon)
Given a project folder that matches the assumptions made by `run.rkt`, we simulate the results of running a full experiment.

### Module Graphs
To make interesting pictures, we require a `.graph` file representing each project.
This is a tab-separated file naming the modules in the project, their position in configuration strings, and their dependencies.

For example, suppose we have a project with three files and the following dependence graph, shown in ASCII:
```
A.rkt <--- B.rkt <--- C.rkt
```
So `A.rkt` does not have any requires, `B.rkt` requires `A.rkt` and is required by `C.rkt`, and `C.rkt` requires `B.rkt`.
Suppose also that the configuration bitstring `100` means that only `A.rkt` is typed and that `001` means that only `C.rkt` is typed.
The `.graph` file for this project must say exactly the following:
```
MODULE	INDEX	REQUIRES
A.rkt	0	
B.rkt	1	A.rkt
C.rkt	2	B.rkt
```
If these files have other requires to files outside the experiment, do _not_ include them in the `.graph` file.

A `.graph` file for the current project must be located in the current directory (where the `main.py` script is invoked) or some sub-directory.
As mentioned above, we infer the name of a graph file by taking the input `FILE.rktd` and stripping everything to the right of the left-most period (`.`) or hyphen (`-`) character, whichever comes first.

Output
------
Running `main.py file.rktd` generates a `.tex` file and a few pictures.

#### TeX
The generated `.tex` file comes in four basic "parts".
- The first page is the most useful.
  It names the project & its modules, and maps the natural number bitstring index to each module.
  It also gives statistics for the untyped, typed, and gradually-typed running times.
- Next are a few pictures summarizing the first page.
  - The normalized runtimes describe how adding types affect the baseline (untyped) performance.
    The bar for "Top 3" shows the least slowdown gradully-typed configurations give.
    The bar for "Bottom 3" shows the greatest slowdown observed on any combination of typed modules.
  - The next image, a violin plot, is useful for seeing the distribution of all gradually-typed configurations.
    That's all it's good for, and we will replace it soon with something more tailored to that job.
  - The third image shows the distribution of running times for all configurations with `N` typed modules (for some fixed `N`).
    This shows how bad things can get after adding types to some part of the project.
- The next four sections detail the best and worst gradually-typed configurations.
  These are the same configurations shown in the "normalized runtimes" bar graph.
  Only now, we get a detailed view of the typed modules and the boundaries in the configuration.
- Last is a family of violin plots comparing the running times when each module is fixed as either typed, or untyped.
  Look for no overlap between different-colored violins.
  (We will replace this picture with a scatterplot or joint distribution. The violin plots were fast, but aren't useful.)

#### Pictures
- `file_normalized-runtimes-bar.png` is a bar graph of a few running times normalized to the average untyped runtime.
  These running times are for:
  - untyped : the fully-untyped configuration
  - gradually typed : the average over all gradually typed configurations
  - top gradual : the average of the most performant 10 (or 10%) gradually-typed configurations
  - bot gradual : the average of the worst (highest overhead) few gradually-typed configurations
  - typed : the fully-typed configuration
- `file_untyped-vs-gradual-vs-typed-violin.png` shows three violin plots side-by-side.
  These plots show the distribution of the fully untyped runtimes, all gradually typed running times, and the fully-typed runtimes.
  (In retrospect, fully-untyped and fully-typed are often poor violins. We only see the variation in our measurements.)
- `file_by-typed-modules-violin.png` stratifies gradually typed configurations by the number of typed modules and shows a violin plot for each.
- `file_module-graph*.png` shows a module graph for one configuration.
  Nodes corresponding to untyped modules are colored differently from nodes corresponding to typed modules, and edges (aka, requires) across a typed/untyped boundary are highlighted red.
- `file_fixing-*.png` picks one module and compares the runtimes of varying everything else while keeping it fixed as typed or as untyped.
  The graph shows two sets of violin plots overlayed on each other; one set is when the file is untyped and the other is for when it is typed.
  Both sets are stratified by the number of typed modules.
  This is a bad picture, but if the two sets never overlap then this module plays a big role in performance.

File Summary
------------
Names and brief descriptions of other files in this folder.

#### config.py
Utilities for working with configuration bitstrings.
These tools understand that strings like "0101" really mean "exactly two modules in this configuration are typed".

#### constants.py
Project-wide constants; for example, location to save output pictures.

#### graphdict.py
Tools for module graph objects.
Infers the location of a `.graph` file and parses the input to reconstruct module dependency information.

#### main.py
Entry point to the project.
Currently, only calls `parser.py`, `tabfile.py`, and finally `render.py` but will probably dispatch to other scripts in the future.

#### parser.py
Parsing command-line arguments.
Does not do much of anything right now, besides computing the module graph.

#### plot.py
Wrapper for `matplotlib`.
Functions for creating bar, box, violin, and module plots.

#### render.py
This file is embarrassing.
It prints summary results to a `.tex` file.
I can't decide if this is better or worse than a pretty printer.

#### sampling.py
Stub, the future home of sampling functions.
Will compute summary results from a directory, without running all configurations.

#### shell.py
Wrapper to Python's subprocess library.
Useful for running and getting output from shell commands.

#### sexp-to-tab.rkt
Convert the output of `run.rkt` to a more-readable `.tab` file.

#### sorted-buffer.py
Also embarrassing.
One function, doing an insert into a sorted array of fixed size.
Pushes out existing elements of size greater than the input.

#### tabfile.py
Compute summary results from the results of `run.rkt` running all configurations.
See above for a discussion of the stats and pictures computed, but for now the definition of a "summary result" is vague.

#### util.py
Simple utility functions, mostly for working with files.

